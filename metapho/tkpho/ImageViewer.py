#!/usr/bin/env python3

"""A TkInter Image Viewer.
   Suitable for embedding in larger apps, or use it by itself
   as a standalone image viewer.

   Copyright 2024 by Akkana -- Share and enjoy under the GPLv2 or later.
"""

import sys, os

import tkinter as tk
from tkinter import filedialog
from PIL import Image, ImageTk, ExifTags, UnidentifiedImageError

VERBOSE = False

FRAC_OF_SCREEN = .85

# The numeric key where EXIF orientation is stored.
# None means it hasn't been initialized yet;
# -1 means there was an error initializing, so EXIF orientation won't work.
EXIF_ORIENTATION_KEY = None


def get_screen_size(root):
    return root.winfo_screenwidth(), root.winfo_screenheight()


class PhoImage:
    INVALID = "Invalid Image"

    def __init__(self, pathname):
        self.pathname = pathname
        self.rotation = 0
        self.exif_rotation = 0

        # The original image as loaded from the file path.
        # This is never rotated.
        self.orig_img = None

        # Image as currently displayed: rotated and scaled
        self.display_img = None

        # If the image couldn't be loaded, an error string is here:
        errstr = None

        # flags, to be set by the user
        flags = []

    def __repr__(self):
        extra = ''
        if self.orig_img:
            extra += ' orig %dx%d' % self.orig_img.size
        if self.display_img:
            extra += ' displayed %dx%d' % self.display_img.size
        return f'<PhoImage {self.pathname}{extra}>'

    # Properties
    def get_size(self):
        if self.display_img:
            return self.display_img.size
        return self.orig_img.size

    size = property(get_size)
    # End Properties

    def load(self):
        """Make sure the image is loaded. May raise FileNotFoundError
           or UnidentifiedImageError.
        """
        # Don't reload if self.orig_img is already there
        if self.orig_img:
            return
        try:
            self.orig_img = Image.open(self.pathname)
            self.rotation = self.get_exif_rotation()
            self.display_img = None

        except FileNotFoundError as e:
            self.orig_img = None
            self.display_img = None
            errstr = f"{self.pathname}: file not found"
            if VERBOSE:
                print(errstr, file=sys.stderr)
            raise e

        except UnidentifiedImageError as e:
            self.orig_img = None
            self.display_img = None
            errstr = f"{self.pathname}: not a recognized image type"
            if VERBOSE:
                print(errstr, file=sys.stderr)
            raise e

    def rotate(self, degrees):
        if VERBOSE:
            print("Rotating", degrees, "starting from", self.rotation,
                  "-->", self.rotation + degrees)
        self.rotation += degrees

        if degrees % 180:
            # If changing aspect ratio, we'll need a new display_img.
            # Clear it, and a new one will be generated by resize_to_fit.
            self.display_img = None
        elif degrees == 180:
            # Rotating without changing aspect ratio:
            # rotate the display_img since size won't change.
            self.display_img = self.display_img.rotate(180)

    def get_exif_rotation(self):
        global EXIF_ORIENTATION_KEY
        # EXIF_ORIENTATION_KEY is currently 274, but don't count on that.
        if EXIF_ORIENTATION_KEY is None:
            EXIF_ORIENTATION_KEY = -1
            for k in ExifTags.TAGS.keys():
                if ExifTags.TAGS[k] == 'Orientation':
                    EXIF_ORIENTATION_KEY = k
                    break
        if EXIF_ORIENTATION_KEY < 0:
            print("Internal error: can't read any EXIF")
            self.exif_rotation = 0
            return 0

        exif = self.orig_img.getexif()
        try:
            if exif[EXIF_ORIENTATION_KEY] == 3:
                self.exif_rotation = 180
            elif exif[EXIF_ORIENTATION_KEY] == 6:
                self.exif_rotation = -90
            elif exif[EXIF_ORIENTATION_KEY] == 8:
                self.exif_rotation = 90
            if VERBOSE:
                print("EXIF rotation is", self.exif_rotation)
            return self.exif_rotation
        except RuntimeError as e:
            print("Problem reading EXIF rotation", file=sys.stderr)
            return self.exif_rotation

    def resize_to_fit(self, bbox):
        """Ensure that display_img, as rotated and scaled, fits in the
           bbox (width, height), reloading from orig_img if needed.
           Return self.display_img, a PIL Image.
        """
        if not self.orig_img:
            self.load()

        # Is there already a display_image of the correct size?
        # That means one dimension should match the bbox, the other is <=
        if self.display_img:
            dw, dh = self.display_img.size
            if ((dw == bbox[0] and dh <= bbox[1]) or
                (dw <= bbox[0] and dh == bbox[1])):
                if VERBOSE:
                    print("display image is already scaled to the window")
                return self.display_img

        # What are the original dimensions, taking rotation into account?
        # (orig_img is not rotated, display_img is)
        if self.rotation % 90:
            oh, ow = self.orig_img.size
        else:
            ow, oh = self.orig_img.size

        # Would the original image fit in the bbox?
        if ow <= bbox[0] and oh <= bbox[1]:
            # It would fit. Is there already a display image that size?
            if self.display_img and self.display_img.size == (ow, oh):
                if VERBOSE:
                    print("display image is already small enough")
                return self.display_img
            # Nope. So create a new display_img, possibly rotated
            if self.rotation % 90:
                self.display_img = self.orig_img.rotate(self.rotation)
            else:
                self.display_img = self.orig_img
            return self.display_img

        # display_img is bigger than the bbox.
        # Need to scale down from orig_img, which may first involve rotating it
        if self.rotation % 180:
            self.display_img = self.orig_img.rotate(self.rotation, expand=True)
        elif self.rotation:
            self.display_img = self.orig_img.rotate(self.rotation, expand=True)
        else:
            self.display_img = self.orig_img

        # Now resize it to fit:
        if VERBOSE:
            print("Resizing to fit in %dx%d" % bbox)
        wratio = self.display_img.size[0] / bbox[0]
        hratio = self.display_img.size[1] / bbox[1]
        ratio = max(wratio, hratio)
        dw, dh = self.display_img.size
        self.display_img = self.display_img.resize(size=(int(dw / ratio),
                                                         int(dh / ratio)))
        if VERBOSE:
            print("Resized to", self.display_img.size)

        return self.display_img


class PhoWidget:
    def __init__(self, root, img_list=[], size=None):
        """If size is omitted, the widget will be free to resize itself,
           otherwise it will try to fit itself in the space available.
        """
        self.img_list = [ PhoImage(f) for f in img_list ]
        self.imgno = -1

        self.root = root    # Needed for queries like screen size

        self.fixed_size = size
        self.widget_size = size
        self.fullscreen = False

        # The actual widget where images will be shown
        if size:
            self.lwidget = tk.Label(root, width=size[0], height=size[1])
        else:
            self.lwidget = tk.Label(root)
        self.lwidget.pack(fill="both", expand=True, padx=0, pady=0)

        self.lwidget.configure(background='black')

    def add_image(self, imgpath):
        """Add an image to the image list.
        """
        self.img_list.append(PhoImage(imgpath))

    def get_widget_size(self):
        return (self.lwidget.winfo_width(),
                self.lwidget.winfo_height())

    def set_fullscreen(self, state):
        self.fullscreen = state
        if state:
            self.set_size(get_screen_size())
        elif self.fixed_size:
            self.widget_size = self.fixed_size
        else:
            self.widget_size = self.get_widget_size()

    def set_size(self, newsize):
        """Change the size of the widget.
           Since this comes from callers outside the widget,
           allow it to override self.fixed_size.
        """
        if VERBOSE:
            print("PhoWidget set_size", newsize)

        if not newsize and not self.widget_size:
            self.widget_size = self.get_widget_size()
            if VERBOSE:
                print("Actual widget size:", self.widget_size)

        # This can be called many times, so don't do anything
        # if nothing changed since last time.
        elif newsize == self.widget_size:
            return

        self.widget_size = newsize

        self.show_image()

    def show_image(self):
        """Show the current image.
           Return 1 for success, 0 for valid image but not ready,
           -1 for invalid image or other error.
        """
        if VERBOSE:
            print("show_image, widget size is", self.widget_size)

        try:
            pil_img = self.resize_to_fit()
        except (FileNotFoundError, UnidentifiedImageError) as e:
            # Any exception means it's not a valid image and should
            # be removed from the list.
            print("Eek, don't know how to handle an exception in show_image",
                  file=sys.stderr)
            print("Exception was:", e)
            return
        if not pil_img:
            print("Eek, resize_to_fit didn't return an image!", file=sys.stderr)
            return

        tkimg = ImageTk.PhotoImage(pil_img)
        self.lwidget.config(image=tkimg)
        self.lwidget.photo = tkimg

        # At this point,
        # self.lwidget.winfo_reqwidth(), self.lwidget.winfo_reqheight()
        # should be the size of the image,
        # though in practice it adds 2 pixels to both height and width.
        # self.lwidget.winfo_width(), self.lwidget.winfo_height()
        # is the size of the previous image, i.e. the current widget size,
        # except at the beginning where it's 1, 1
        if VERBOSE:
            print("Showing", self.img_list[self.imgno], '\n')

            # help(self.lwidget)
            # print("Current widget size:", self.lwidget.size())
            # print("size", self.lwidget.width, self.lwidget.height)
            # print("winfo size:", self.lwidget.winfo_width(), self.lwidget.winfo_height())
            # print("Requested size:", self.lwidget.winfo_reqwidth(), self.lwidget.winfo_reqheight())
            # print("Geometry:", self.lwidget.winfo_geometry())
            # print("Position:", self.lwidget.winfo_x(), self.winfo_y())

    def resize_to_fit(self):
        """Resize the current image to fit in the current widget.
           but no larger than the bbox (width, height).
        """
        if self.fullscreen:
            target_size = get_screen_size(self.root)
            if VERBOSE:
                print("resize_to_fit, fullscreen,", target_size)

        elif not self.fixed_size:                  # resizable
            if VERBOSE:
                print("Resizable widget")
            target_size = (self.root.winfo_screenwidth() * FRAC_OF_SCREEN,
                           self.root.winfo_screenheight() * FRAC_OF_SCREEN)
            if VERBOSE:
                print("resize_to_fit, variable height ->", target_size)

        else:                                      # fixed-size window
            target_size = self.widget_size
            if VERBOSE:
                print("resize_to_fit, fixed at", target_size)

        if VERBOSE:
            print("Target space:", target_size)
        return self.img_list[self.imgno].resize_to_fit(target_size)

    def next_image(self):
        if not self.img_list:
            print("Error: no image list!")
            return

        self.imgno += 1
        while True:
            if self.imgno >= len(self.img_list):
                self.imgno = len(self.img_list) - 1
                if VERBOSE:
                    print("Can't go beyond last image")
                # Special case: if none of the images are viewable,
                # we'll get here without anything to show.
                if not self.img_list:
                    print("Couldn't show any of the images", file=sys.stderr)
                    sys.exit(1)
                return

            # Is the current image valid?
            try:
                self.img_list[self.imgno].load()
            except (FileNotFoundError, UnidentifiedImageError) as e:
                print("Skipping", self.img_list[self.imgno], e)
                del self.img_list[self.imgno]
                continue

            # Whew, load() worked okay, the image is valid
            if VERBOSE:
                print("  to", self.imgno, "->", self.img_list[self.imgno])

            self.show_image()
            return

    def prev_image(self):
        if not self.img_list:
            print("Error: no image list!")
            return

        while True:
            self.imgno -= 1
            if self.imgno < 0:
                self.imgno = 0
                if VERBOSE:
                    print("Can't look before first image")
                return

            # Is the current image valid?
            try:
                self.img_list[self.imgno].load()
            except (FileNotFoundError, UnidentifiedImageError) as e:
                print("Skipping", self.img_list[self.imgno], e)
                del self.img_list[self.imgno]
                continue

            # Whew, load() worked okay, the image is valid
            if VERBOSE:
                print("  to", self.imgno, "->", self.img_list[self.imgno])
            self.show_image()
            return

    def goto_imageno(self, imagenum):
        num_images = len(self.img_list)
        if imagenum >= num_images:
            self.imgno = num_images()
            self.prev_image()
            return
        if imagenum < 0:
            # For negative numbers, count back, -1 being the last image
            self.imgno = num_images - imagenum - 1
            self.prev_image()
            return
        self.imgno = imagenum - 1
        self.next_image()
        return

    def rotate(self, rotation):
        self.img_list[self.imgno].rotate(rotation)
        self.show_image()


class PhoWindow:
    def __init__(self, img_list=[], width=0, height=0,
                 allow_resize=True, exit_on_q=True):

        self.root = tk.Tk()

        self.root.title("Pho Image Viewer")

        # To allow resizing, set self.fixed_size to None
        if allow_resize:
            self.fixed_size = None
        else:
            self.fixed_size = (1200, 900)
        self.viewer = PhoWidget(self.root, img_list,
                                        size=self.fixed_size)

        self.root.bind('<Key-space>', self.image_nav_handler)
        self.root.bind('<Key-BackSpace>', self.image_nav_handler)
        self.root.bind('<Key-Home>', self.image_nav_handler)
        self.root.bind('<Key-End>', self.image_nav_handler)

        self.root.bind('<Key-Right>',
                       lambda e: self.rotate_handler(e, -90))
        self.root.bind('<Key-Left>',
                       lambda e: self.rotate_handler(e, 90))
        self.root.bind('<Key-Up>',
                       lambda e: self.rotate_handler(e, 180))
        self.root.bind('<Key-Down>',
                       lambda e: self.rotate_handler(e, 180))

        self.root.bind('<Key-f>', self.fullscreen_handler)
        self.root.bind('<Key-Escape>', self.fullscreen_handler)

        if self.fixed_size:
            self.root.bind("<Configure>", self.resize_handler)

        if exit_on_q:
            self.root.bind('<Key-q>', self.quit_handler)
            self.root.bind('<Control-Key-q>', self.quit_handler)

    def run(self):
        self.viewer.next_image()
        self.root.mainloop()

    def add_image(img):
        self.viewer.add_image(img)

    def image_nav_handler(self, event):
        if event.keysym == 'space':
            self.viewer.next_image()
            return
        if event.keysym == 'BackSpace':
            self.viewer.prev_image()
            return
        if event.keysym == 'Home':
            self.viewer.goto_imageno(0)
            return
        if event.keysym == 'End':
            self.viewer.goto_imageno(-1)
            return

    def rotate_handler(self, event, rotation):
        self.viewer.rotate(rotation)

    def resize_handler(self, event):
        if (event.width, event.height) != self.fixed_size:
            if self.fixed_size:
                if VERBOSE:
                    print("Window resize! New size is",
                          event.width, event.height)
                self.fixed_size = (event.width, event.height)
                self.viewer.set_size(self.fixed_size)
                self.viewer.show_image()
            elif VERBOSE:
               print("Resize event, but who cares?")

    def fullscreen_handler(self, event):
        """f toggles, ESC gets out of fullscreen"""
        # Escape should always exit fullscreen
        if (event.keysym == 'Escape' or
            self.root.attributes('-fullscreen')):  # already fullscreen
            self.root.attributes("-fullscreen", False)
            # Sadly, the viewer widget can't just check the root attributes
            # before set_size(), because the root attribute won't actually
            # change until later, so now, it will still show as True.
            self.viewer.set_fullscreen(False)
            if VERBOSE:
                print("Out of fullscreen, fixed_size is", self.fixed_size)
 
        else:
            # Into fullscreen
            self.root.attributes("-fullscreen", True)
            if VERBOSE:
                print("Now in fullscreen, size", self.viewer.widget_size)
            self.viewer.fullscreen = True
            self.viewer.set_size((self.root.winfo_screenwidth(),
                                  self.root.winfo_screenheight()))

        # viewer.set_size() should redraw as necessary

    def quit_handler(self, event):
        if VERBOSE:
            print("Bye")
        sys.exit(0)


if __name__ == '__main__':
    import argparse
    parser = argparse.ArgumentParser(
        description="Pho, an image viewer and tagger")
    parser.add_argument('-d', "--debug", dest="debug", default=False,
                        action="store_true", help="Print debugging messages")
    parser.add_argument('-R', "--randomize", dest="randomize", default=False,
                        action="store_true",
                        help="Present images in random order")
    parser.add_argument('-v', "--verbosehelp", dest="verbosehelp",
                        default=False,
                        action="store_true", help="Print verbose help")
    parser.add_argument('images', nargs='+', help="Images to show")
    args = parser.parse_args(sys.argv[1:])

    if args.debug:
        VERBOSE = True

    if args.randomize:
        random.seed()
        args.images = random.shuffle(args.images)

    pwin = PhoWindow(args.images)
    pwin.run()

