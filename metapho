#!/usr/bin/env python

# metapho: an image tagger and viewer.

# Copyright 2013 by Akkana Peck: share and enjoy under the GPL v2 or later.

import MetaPho

import gtk
import glib
import gc
import sys, os

class MetaPhoGTKTagViewer(MetaPho.Tagger, gtk.Table) :
    '''A PyGTK widget for showing tags.
    '''
    def __init__(self) :
        print "Global tag list:", MetaPho.Tagger.gTagList

        gtk.Table.__init__(self, 2, 20, False)

        self.title = gtk.Label("Tags")
        self.attach_defaults(self.title, 0, 2, 0, 1 );
        self.title.show()

        # Set up a bunch of entries, also setting the table size:
        self.buttons = []
        self.entries = []
        for i in range(0, 20) :
            button = gtk.ToggleButton(str(i))
            self.attach_defaults(button, 0, 1, i, i+1 );
            self.buttons.append(button)

            entry = gtk.Entry()
            entry.set_width_chars(35)
            self.attach_defaults(entry, 1, 2, i, i+1 );
            self.entries.append(entry)

        self.show()

    def displayTags(self) :
        '''Call this after readTags() has been read for all directories.'''

        for i in range(len(self.entries)) :
            if i < len(MetaPho.Tagger.gTagList) :
                print "Tag", i, ":", MetaPho.Tagger.gTagList[i]
                self.entries[i].set_text(MetaPho.Tagger.gTagList[i])

        if len(MetaPho.Tagger.gTagList) > len(self.entries) :
            print "Too many tags -- can't show all", \
                len(MetaPho.Tagger.gTagList)

    def highlightTag(self, tagno, val) :
        '''Turn tag number tagno on (if val=True) or off (val=False).'''
        self.buttons[tagno].set_active(val)
        if val :
            self.entries[tagno].modify_base(gtk.STATE_NORMAL,
                                            gtk.gdk.color_parse("#FFFFFF"))

        else :
            self.entries[tagno].modify_base(gtk.STATE_NORMAL,
                                            gtk.gdk.color_parse("#DDDDDD"))

    def setImage(self, img) :
        MetaPho.Tagger.setImage(self, img)

        self.title.set_text(os.path.basename(img.filename))

        for i in xrange(len(self.entries)) :
            self.highlightTag(i, False)

        for i, tagstr in enumerate(img.tags) :
            self.highlightTag(img.tags[i], True)
            #self.set_tag_n(i, tagstr)

        return
        # un-highlight any remaining entries.
        if len(self.entries) > len(img.tags) :
            for i in range(len(img.tags), len(self.entries)) :
                self.buttons[i].set_active(False)
                self.entries[i].set_text("")
                # background color
                self.entries[i].modify_base(gtk.STATE_NORMAL,
                                            gtk.gdk.color_parse("#DDDDDD"))

    def set_tag_n(self, n, tag) :
        '''Display a tag string in the Nth entry.'''
        print "set_tag_n", n, tag, MetaPho.Tagger.gTagList[tag]

        # Then set the string
        print "Setting entry", n, "of", len(self.entries), \
            "to", tag, MetaPho.Tagger.gTagList[tag]
        self.buttons[n].set_active(True)
        self.entries[n].set_text(MetaPho.Tagger.gTagList[tag])
        self.entries[n].modify_base(gtk.STATE_NORMAL,
                                    gtk.gdk.color_parse("#FFFFFF"))

class MetaPhoGTKViewer(gtk.DrawingArea) :
    '''A PyGTK image viewer widget for MetaPho.
    '''

    def __init__(self) :
        super(MetaPhoGTKViewer, self).__init__()
        self.connect("expose-event", self.expose_handler)
        self.gc = None
        self.pixbuf = None
        self.imgwidth = None
        self.imgheight = None
        self.cur_img = None

    def expose_handler(self, widget, event) :
        print "Expose"

        if not self.gc :
            self.gc = widget.window.new_gc()
            x, y, self.imgwidth, self.imgheight = self.get_allocation()
            print "viewer is %d x %d" % (self.imgwidth, self.imgheight)

            # Have we had loadImage called, but we weren't ready for it?
            # Now, theoretically, we are ... so call it again.
            if self.cur_img and not self.pixbuf :
                self.loadImage(self.cur_img)

        self.showImage()

    # Mapping from EXIF orientation tag to degrees rotated.
    # http://sylvana.net/jpegcrop/exif_orientation.html
    exif_rot_table = [ 0, 0, 180, 180, 270, 270, 90, 90 ]
    # Note that orientations 2, 4, 5 and 7 also involve a flip.
    # We're not implementing that right now, because nobody
    # uses it in practice.

    def loadImage(self, img) :
        '''Load the image passed in, and show it.
           img is a MetaPho.Image object.
           Return True for success, False for error.
        '''

        print "viewer: Trying to load", img.filename
        self.cur_img = img

        # Clean up memory from any existing pixbuf.
        # This still needs to be garbage collected before returning.
        if self.pixbuf :
            self.pixbuf = None

        try :
            newpb = gtk.gdk.pixbuf_new_from_file(img.filename)

            # We can't do any of the rotation until the window appears
            # so we know our window size.
            # But we have to load the first pixbuf anyway, because
            # otherwise we may end up pointing to an image that can't
            # be loaded. Super annoying! We'll end up reloading the
            # pixbuf again after the window appears, so this will
            # slow down the initial window slightly.
            if not self.imgwidth :
                print "Can't finish loading before drawingArea is exposed"
                return True

            # Do we need to check rotation info for this image?
            if img.rot == None :
                # Get the EXIF embedded rotation info.
                print "Getting orientation for", img.filename,
                print "got", newpb.get_option('orientation')
                orient = newpb.get_option('orientation')
                if orient == None :    # No orientation specified; use 0
                    orient = 0
                else :                 # convert to int array index
                    orient = int(orient) - 1
                img.rot = self.exif_rot_table[orient]
                print "Rotation is", img.rot,
                print "exif tag", newpb.get_option('orientation')

            # Scale the image to our display image size.
            # We need it to fit in the space available.
            # If we're not changing aspect ratios, that's easy.
            oldw = newpb.get_width()
            oldh = newpb.get_height()
            print "Orig size:", oldw, oldh
            if img.rot in [ 0, 180] :
                if oldw > oldh :     # horizontal format photo
                    neww = self.imgwidth
                    newh = oldh * self.imgwidth / oldw
                else :               # vertical format
                    newh = self.imgheight
                    neww = oldw * self.imgheight / oldh

            # If the image needs to be rotated 90 or 270 degrees,
            # scale so that the scaled width will fit in the image
            # height area -- even though it's still width because we
            # haven't rotated yet.
            else :     # We'll be changing aspect ratios
                print "......... Changing aspect ratio!"
                if oldw > oldh :     # horizontal format, will be vertical
                    neww = self.imgheight
                    newh = oldh * self.imgheight / oldw
                else :               # vertical format, will be horiz
                    neww = self.imgwidth
                    newh = oldh * self.imgwidth / oldw

            # Finally, do the scale:
            newpb = newpb.scale_simple(neww, newh,
                                             gtk.gdk.INTERP_BILINEAR)

            # Rotate the image if needed
            if img.rot != 0 :
                print "Rotating by", img.rot
                newpb = newpb.rotate_simple(img.rot)

            # newpb = newpb.apply_embedded_orientation()

            self.pixbuf = newpb

            print "Loaded", img.filename
            self.showImage()
            loaded = True

        except glib.GError :
            print "Oops, couldn't load", img.filename
            self.pixbuf = None
            loaded = False

        # garbage collect the old pixbuf, if any, and the one we just read in:
        newpb = None
        gc.collect()

        return loaded

    def showImage(self) :
        if not self.gc :
            print "Not ready yet"
            return

        if not self.pixbuf :
            print "No image loaded yet, can't show"
            return

        # if not self.pixbuf :
        #     self.loadImage()
        #     if not self.pixbuf :
        #         return

        # Clear the drawingarea first
        self.window.draw_rectangle(self.gc, True, 0, 0,
                                                self.imgwidth, self.imgheight)

        x = (self.imgwidth - self.pixbuf.get_width()) / 2
        y = (self.imgheight - self.pixbuf.get_height()) / 2
        self.window.draw_pixbuf(self.gc, self.pixbuf, 0, 0, x, y)

    def rotate(self, rot) :
        self.cur_img.rot = (self.cur_img.rot + rot + 360) % 360

        # XXX we don't always need to reload: can make this more efficient.
        self.loadImage(self.cur_img)

class MetaPhoWindow(object):
    '''The main controller window for MetaPho.
       This holds any child widgets, like the image viewer and tags window,
       and manages key events and other user commands.
    '''

    def __init__(self, file_list):
        print "initializing from", file_list
        for filename in file_list :
            MetaPho.Image.gImageList.append(MetaPho.Image(filename))
        self.imgno = 0

        # Window size.
        # Eventually, calculate these somehow or read from prefs
        #self.width = 1024
        #self.height = 768

        # The size of the image viewing area:
        self.imgwidth = 640
        self.imgheight = 600

        self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win.set_border_width(10)

        self.win.connect("delete_event", self.quit)
        self.win.connect("destroy", self.quit)

        # Showing the first image is a problem. We need to call
        # firstImage() at some point, but we can't load any images
        # until after the viewer has been exposed at least once.
        # So even though blah blah XXX
        # self.win.connect_after("expose", self.realize_handler)

        main_hbox = gtk.HBox(spacing=8)

        self.viewer = MetaPhoGTKViewer()
        self.viewer.set_size_request(self.imgwidth, self.imgheight)
        main_hbox.pack_start(self.viewer)

        self.tagger = MetaPhoGTKTagViewer()
        main_hbox.pack_start(self.tagger, expand=True)

        #self.win.set_default_size(self.width, self.height)

        self.win.add(main_hbox)

        self.win.connect("key-press-event", self.key_press_event)
        self.win.show_all();

        self.readAllTags()

    def realize_handler(self, widget, event) :
        self.firstImage()

    def quit(self, widget=None, data=None):
        gtk.main_quit()

    def readAllTags(self) :
        '''Read tags in all directories used by images in argv.
           XXX But for now, just take the dirname of the first image.
        '''
        dirlist = []
        for img in MetaPho.Image.gImageList :
            dirname = os.path.dirname(img.filename)
            if dirname not in dirlist :
                dirlist.append(dirname)
                self.tagger.readTags(dirname)
        self.tagger.displayTags()

        print "All tags:", '\n'.join(MetaPho.Tagger.gTagList)
        print "All images:", MetaPho.Image.gImageList

    def firstImage(self) :
        self.imgno = -1
        self.nextImage()

    def lastImage(self) :
        self.imgno = len(MetaPho.Image.gImageList)
        self.prevImage()

    def nextImage(self) :
        '''Advance to the next image, if possible.
           Tell the viewer to load and show the image.
        '''
        loaded = False
        while self.imgno < len(MetaPho.Image.gImageList)-1 and not loaded :
            self.imgno += 1
            loaded = self.viewer.loadImage(MetaPho.Image.gImageList[self.imgno])
            if not loaded :
                print "Ignoring", MetaPho.Image.gImageList[self.imgno].filename
                del(MetaPho.Image.gImageList[self.imgno])
                # We're about to increment imgno, but we actually want it
                # to stay the same since deleting the nonexistent image
                # slid the next image into the current position;
                # so decrement imgno now.
                self.imgno -= 1

        if loaded :
            self.tagger.setImage(MetaPho.Image.gImageList[self.imgno])

        else :           # couldn't load anything in the list
            print "No more images"

    def prevImage(self) :
        loaded = False
        while self.imgno >= 1 and not loaded :
            self.imgno -= 1
            loaded = self.viewer.loadImage(MetaPho.Image.gImageList[self.imgno])
            if not loaded :
                print "Ignoring", MetaPho.Image.gImageList[self.imgno].filename
                del(MetaPho.Image.gImageList[self.imgno])

        if loaded :
            self.tagger.setImage(MetaPho.Image.gImageList[self.imgno])
        else :          # couldn't load anything in the list
            print "Can't go before first image"

    # Called whenever any key is pressed:
    def key_press_event(self, widget, event) :
        if event.string == "q" :
            self.quit()
            return True
        if event.string == " " :
            self.nextImage()
            return True 
        if event.keyval == gtk.keysyms.BackSpace :
            self.prevImage()
            return True
        if event.keyval == gtk.keysyms.Home :
            self.firstImage()
            return True
        if event.keyval == gtk.keysyms.End :
            self.lastImage()
            return True
        if event.keyval == gtk.keysyms.Right :
            self.viewer.rotate(270)
            return True
        if event.keyval == gtk.keysyms.Left :
            self.viewer.rotate(90)
            return True
        if event.keyval in [ gtk.keysyms.Up, gtk.keysyms.Down ] :
            self.viewer.rotate(180)
            return True

        # A key we didn't understand
        print "Read key:", event.string, "keyval", event.keyval
        return False

    def main(self):
        gtk.main()

if __name__ == '__main__':
    metapho = MetaPhoWindow(sys.argv[1:])
    metapho.firstImage()
    metapho.main()
