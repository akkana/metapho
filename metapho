#!/usr/bin/env python

# metapho: an image tagger and viewer.

# Copyright 2013 by Akkana Peck: share and enjoy under the GPL v2 or later.

import gtk
import glib
import gc
import sys, os
import shlex

class MetaPhoImage :
    '''An image, with additional info such as rotation and tags.
       Eventually methods like delete() to delete the file from disk
       will probably also live in this class.
    '''

    gImageList = []

    def __init__(self, filename) :
        self.filename = filename
        self.tags = []
        self.rot = None      # None means we don't know yet, 0 means stay at 0
        # Note: use 270 for counter-clockwise rotation, not -90.

    def __repr__(self) :
        str = "Image %s" % self.filename

        if self.rot :
            str += " (rotation %s)" % self.rot

        if self.tags :
            str += " Tags: " + self.tags.__repr__()

        str += '\n'

        return str

    # Next two perhaps belong in MetaPhoTagger, not here.
    def addTag(self, tag) :
        '''Add a tag to this image.
           tag may be a string, which can be a new string or an existing one,
           or an integer index into the tag list.
           Return the index of the tag just added, or None if error.
        '''
        return None

    def matchTag(self, pattern) :
        '''Return a list of tags matching the pattern.'''
        return None

class MetaPhoTagger(object) :
    '''Manages tags for images.
    '''

    gTagList = []
    '''The list of tags is common to every image in the application.
    '''

    def __init__(self) :
        '''imagelist: a list of MetaPhoImages'''
        pass

    def readTags(self, dirname) :
        '''Read in tags from files named in the given directory,
           and tag images in the imagelist appropriately.
           Tags will be appended to MetaPhoTagger.gTagList.
        '''
        # Might want to be recursive and use os.walk ...
        # or maybe go the other way, search for Tags files
        # *above* the current directory but not below.
        # For now, only take the given directory.
        '''off-the-cuff example format:
tagtype People: Alice, Bill, Charlie, Dennis
tagtype Places: America, Belgium, Czech Republic, Denmark
photo p103049.jpg: Alice, Belgium
photo p103050.jpg: Charlie, Denmark
photo p103051.jpg: Charlie, Bill, Denmark
tag Alice: p103049.jpg
tag Belgium: p103049.jpg
tag Bill: p103051.jpg
tag Charlie: p103050.jpg, p103051.jpg
tag Denmark: p103050.jpg, p103051.jpg
        '''
        try :
            pathname = os.path.join(dirname, "Tags")
            fp = open(pathname)
            print "Opened", pathname
        except IOError :
            try :
                pathname = os.path.join(dirname, "Keywords")
                fp = open(pathname)
            except IOError :
                print "No Tags file in", dirname
                return

        for line in fp :
            colon = line.find(':')
            if colon < 0 :
                continue    # If there's no colon, it's not a legal tag line

            # Now we know we have tagname, typename or photoname.
            # Get the list of objects after the colon.
            # Use shlex to handle quoted and backslashed
            # filenames with embedded spaces.
            try :
                objects = shlex.split(line[colon+1:].strip())
            except ValueError:
                print pathname, "Couldn't parse:", line
                continue

            if line.startswith('tag ') :
                tagname = line[4:colon].strip()
                print "Tag", tagname, ": objects", objects
                self.processTag(tagname, objects)

            elif line.startswith('tagtype ') :
                typename = line[8:colon].strip()

            elif line.startswith('photo ') :
                photoname = line[6:colon].strip()

            else :
                # Assume it's a tag: file file file line
                tagname = line[:colon].strip()
                print "Keyword", tagname, ": objects", objects
                self.processTag(tagname, objects)

        fp.close()

    def processTag(self, tagname, filenames) :
        '''After reading a tag from a tags file, add it to the global
           tags list if it isn't there already, and add the given filenames
           to it.
        '''
        try :
            tagindex = MetaPhoTagger.gTagList.index(tagname)
        except :
            tagindex = len(MetaPhoTagger.gTagList)
            MetaPhoTagger.gTagList.append(tagname)

        # Search for images matching the names in filenames
        # XXX pathname issue here: filenames in tag files generally don't
        # have absolute pathnames, so we're only matching basenames and
        # there could be collisions.
        for img in MetaPhoImage.gImageList :
            for fil in filenames :
                if img.filename.endswith(fil) and tagindex not in img.tags :
                    img.tags.append(tagindex)

    def setImage(self, img) :
        '''Set the current image to img (a MetaPhoImage).
           Load the associated tags, and (in derived classes) show them
           in whatever way is appropriate.
        '''
        print "Current", img
        print "Current tags:", img.tags
        for tagindex in img.tags :
            print "  ", MetaPhoTagger.gTagList[tagindex]

class MetaPhoGTKTagViewer(MetaPhoTagger, gtk.VBox) :
    '''A PyGTK widget for showing tags.
    '''
    def __init__(self) :
        gtk.VBox.__init__(self)

        self.title = gtk.Label("Tags")
        self.pack_start(self.title, expand=False)
        self.title.show()

        self.entries = []

        self.show()

    def setImage(self, img) :
        MetaPhoTagger.setImage(self, img)

        self.title.set_text(os.path.basename(img.filename))

        for i, tagstr in enumerate(img.tags) :
            self.set_tag_n(i, tagstr)

        # If there were any showing before, hide them
        if len(self.entries) > len(img.tags) :
            for i in range(len(img.tags), len(self.entries)) :
                self.entries[i].hide()

    def set_tag_n(self, n, tag) :
        '''Display a tag string in the Nth entry.'''
        print "set_tag_n", n, tag, MetaPhoTagger.gTagList[tag]
        # First, create any that aren't there yet:
        if len(self.entries) < n+2 :
            print "Making new entries"
            for i in range(len(self.entries), n+1) :
                print "new", i
                entry = gtk.Entry()
                entry.set_width_chars(35)
                self.pack_start(entry, expand=False)
                entry.show()
                self.entries.append(entry)

        # Then set the string
        print "Setting entry", n, "of", len(self.entries), \
            "to", tag, MetaPhoTagger.gTagList[tag]
        self.entries[n].set_text(MetaPhoTagger.gTagList[tag])
        self.entries[n].show()

class MetaPhoGTKViewer(gtk.DrawingArea) :
    '''A PyGTK image viewer widget for MetaPho.
    '''

    def __init__(self) :
        super(MetaPhoGTKViewer, self).__init__()
        self.connect("expose-event", self.expose_handler)
        self.gc = None
        self.pixbuf = None
        self.imgwidth = None
        self.imgheight = None
        self.cur_img = None

    def expose_handler(self, widget, event) :
        print "Expose"

        if not self.gc :
            self.gc = widget.window.new_gc()
            x, y, self.imgwidth, self.imgheight = self.get_allocation()
            print "viewer is %d x %d" % (self.imgwidth, self.imgheight)

            # Have we had loadImage called, but we weren't ready for it?
            # Now, theoretically, we are ... so call it again.
            if self.cur_img and not self.pixbuf :
                self.loadImage(self.cur_img)

        self.showImage()

    # Mapping from EXIF orientation tag to degrees rotated.
    # http://sylvana.net/jpegcrop/exif_orientation.html
    exif_rot_table = [ 0, 0, 180, 180, 270, 270, 90, 90 ]
    # Note that orientations 2, 4, 5 and 7 also involve a flip.
    # We're not implementing that right now, because nobody
    # uses it in practice.

    def loadImage(self, img) :
        '''Load the image passed in, and show it.
           img is a MetaPhoImage object.
           Return True for success, False for error.
        '''

        print "viewer: Trying to load", img.filename
        self.cur_img = img

        # Clean up memory from any existing pixbuf.
        # This still needs to be garbage collected before returning.
        if self.pixbuf :
            self.pixbuf = None

        try :
            newpb = gtk.gdk.pixbuf_new_from_file(img.filename)

            # We can't do any of the rotation until the window appears
            # so we know our window size.
            # But we have to load the first pixbuf anyway, because
            # otherwise we may end up pointing to an image that can't
            # be loaded. Super annoying! We'll end up reloading the
            # pixbuf again after the window appears, so this will
            # slow down the initial window slightly.
            if not self.imgwidth :
                print "Can't finish loading before drawingArea is exposed"
                return True

            # Do we need to check rotation info for this image?
            if img.rot == None :
                # Get the EXIF embedded rotation info.
                print "Getting orientation for", img.filename,
                print "got", newpb.get_option('orientation')
                orient = newpb.get_option('orientation')
                if orient == None :    # No orientation specified; use 0
                    orient = 0
                else :                 # convert to int array index
                    orient = int(orient) - 1
                img.rot = self.exif_rot_table[orient]
                print "Rotation is", img.rot,
                print "exif tag", newpb.get_option('orientation')

            # Scale the image to our display image size.
            # We need it to fit in the space available.
            # If we're not changing aspect ratios, that's easy.
            oldw = newpb.get_width()
            oldh = newpb.get_height()
            print "Orig size:", oldw, oldh
            if img.rot in [ 0, 180] :
                if oldw > oldh :     # horizontal format photo
                    neww = self.imgwidth
                    newh = oldh * self.imgwidth / oldw
                else :               # vertical format
                    newh = self.imgheight
                    neww = oldw * self.imgheight / oldh

            # If the image needs to be rotated 90 or 270 degrees,
            # scale so that the scaled width will fit in the image
            # height area -- even though it's still width because we
            # haven't rotated yet.
            else :     # We'll be changing aspect ratios
                print "......... Changing aspect ratio!"
                if oldw > oldh :     # horizontal format, will be vertical
                    neww = self.imgheight
                    newh = oldh * self.imgheight / oldw
                else :               # vertical format, will be horiz
                    neww = self.imgwidth
                    newh = oldh * self.imgwidth / oldw

            # Finally, do the scale:
            newpb = newpb.scale_simple(neww, newh,
                                             gtk.gdk.INTERP_BILINEAR)

            # Rotate the image if needed
            if img.rot != 0 :
                print "Rotating by", img.rot
                newpb = newpb.rotate_simple(img.rot)

            # newpb = newpb.apply_embedded_orientation()

            self.pixbuf = newpb

            print "Loaded", img.filename
            self.showImage()
            loaded = True

        except glib.GError :
            print "Oops, couldn't load", img.filename
            self.pixbuf = None
            loaded = False

        # garbage collect the old pixbuf, if any, and the one we just read in:
        newpb = None
        gc.collect()

        return loaded

    def showImage(self) :
        if not self.gc :
            print "Not ready yet"
            return

        if not self.pixbuf :
            print "No image loaded yet, can't show"
            return

        # if not self.pixbuf :
        #     self.loadImage()
        #     if not self.pixbuf :
        #         return

        # Clear the drawingarea first
        self.window.draw_rectangle(self.gc, True, 0, 0,
                                                self.imgwidth, self.imgheight)

        x = (self.imgwidth - self.pixbuf.get_width()) / 2
        y = (self.imgheight - self.pixbuf.get_height()) / 2
        self.window.draw_pixbuf(self.gc, self.pixbuf, 0, 0, x, y)

    def rotate(self, rot) :
        self.cur_img.rot = (self.cur_img.rot + rot + 360) % 360

        # XXX we don't always need to reload: can make this more efficient.
        self.loadImage(self.cur_img)

class MetaPhoWindow(object):
    '''The main controller window for MetaPho.
       This holds any child widgets, like the image viewer and tags window,
       and manages key events and other user commands.
    '''

    def __init__(self, file_list):
        print "initializing from", file_list
        for filename in file_list :
            MetaPhoImage.gImageList.append(MetaPhoImage(filename))
        self.imgno = 0

        # Window size.
        # Eventually, calculate these somehow or read from prefs
        #self.width = 1024
        #self.height = 768

        # The size of the image viewing area:
        self.imgwidth = 640
        self.imgheight = 600

        self.win = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.win.set_border_width(10)

        self.win.connect("delete_event", self.quit)
        self.win.connect("destroy", self.quit)

        # Showing the first image is a problem. We need to call
        # firstImage() at some point, but we can't load any images
        # until after the viewer has been exposed at least once.
        # So even though blah blah XXX
        # self.win.connect_after("expose", self.realize_handler)

        main_hbox = gtk.HBox(spacing=8)

        self.viewer = MetaPhoGTKViewer()
        self.viewer.set_size_request(self.imgwidth, self.imgheight)
        main_hbox.pack_start(self.viewer)

        self.tagger = MetaPhoGTKTagViewer()
        main_hbox.pack_start(self.tagger, expand=True)

        #self.win.set_default_size(self.width, self.height)

        self.win.add(main_hbox)

        self.win.connect("key-press-event", self.key_press_event)
        self.win.show_all();

        self.readAllTags()

    def realize_handler(self, widget, event) :
        self.firstImage()

    def quit(self, widget=None, data=None):
        gtk.main_quit()

    def readAllTags(self) :
        '''Read tags in all directories used by images in argv.
           XXX But for now, just take the dirname of the first image.
        '''
        dirlist = []
        for img in MetaPhoImage.gImageList :
            dirname = os.path.dirname(img.filename)
            if dirname not in dirlist :
                dirlist.append(dirname)
                self.tagger.readTags(dirname)

        print "All tags:", MetaPhoTagger.gTagList
        print "All images:", MetaPhoImage.gImageList

    def firstImage(self) :
        self.imgno = -1
        self.nextImage()

    def lastImage(self) :
        self.imgno = len(MetaPhoImage.gImageList)
        self.prevImage()

    def nextImage(self) :
        '''Advance to the next image, if possible.
           Tell the viewer to load and show the image.
        '''
        loaded = False
        while self.imgno < len(MetaPhoImage.gImageList)-1 and not loaded :
            self.imgno += 1
            loaded = self.viewer.loadImage(MetaPhoImage.gImageList[self.imgno])
            if not loaded :
                print "Ignoring", MetaPhoImage.gImageList[self.imgno].filename
                del(MetaPhoImage.gImageList[self.imgno])
                # We're about to increment imgno, but we actually want it
                # to stay the same since deleting the nonexistent image
                # slid the next image into the current position;
                # so decrement imgno now.
                self.imgno -= 1

        if loaded :
            self.tagger.setImage(MetaPhoImage.gImageList[self.imgno])

        else :           # couldn't load anything in the list
            print "No more images"

    def prevImage(self) :
        loaded = False
        while self.imgno >= 1 and not loaded :
            self.imgno -= 1
            loaded = self.viewer.loadImage(MetaPhoImage.gImageList[self.imgno])
            if not loaded :
                print "Ignoring", MetaPhoImage.gImageList[self.imgno].filename
                del(MetaPhoImage.gImageList[self.imgno])

        if loaded :
            self.tagger.setImage(MetaPhoImage.gImageList[self.imgno])
        else :          # couldn't load anything in the list
            print "Can't go before first image"

    # Called whenever any key is pressed:
    def key_press_event(self, widget, event) :
        if event.string == "q" :
            self.quit()
            return True
        if event.string == " " :
            self.nextImage()
            return True 
        if event.keyval == gtk.keysyms.BackSpace :
            self.prevImage()
            return True
        if event.keyval == gtk.keysyms.Home :
            self.firstImage()
            return True
        if event.keyval == gtk.keysyms.End :
            self.lastImage()
            return True
        if event.keyval == gtk.keysyms.Right :
            self.viewer.rotate(270)
            return True
        if event.keyval == gtk.keysyms.Left :
            self.viewer.rotate(90)
            return True
        if event.keyval in [ gtk.keysyms.Up, gtk.keysyms.Down ] :
            self.viewer.rotate(180)
            return True

        # A key we didn't understand
        print "Read key:", event.string, "keyval", event.keyval
        return False

    def main(self):
        gtk.main()

if __name__ == '__main__':
    metapho = MetaPhoWindow(sys.argv[1:])
    metapho.firstImage()
    metapho.main()
